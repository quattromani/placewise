<!DOCTYPE  html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>doc</title>
    <style>
      /*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }
    </style>
  </head>
  <body>  
    <h1 id="controlling-flow-callbacks-are-easy">Controlling Flow: callbacks are easy</h1>
<h2 id="what-s-actually-hard-">What&#39;s actually hard?</h2>
<ul>
<li>Doing a bunch of things in a specific order.</li>
<li>Knowing when stuff is done.</li>
<li>Handling failures.</li>
<li>Breaking up functionality into parts (avoid nested inline callbacks)</li>
</ul>
<h2 id="common-mistakes">Common Mistakes</h2>
<ul>
<li>Abandoning convention and consistency.</li>
<li>Putting all callbacks inline.</li>
<li>Using libraries without grokking them.</li>
<li>Trying to make async code look sync.</li>
</ul>
<h2 id="define-conventions">Define Conventions</h2>
<ul>
<li>Two kinds of functions: <em>actors</em> take action, <em>callbacks</em> get results.</li>
<li>Essentially the continuation pattern. Resulting code <em>looks</em> similar
to fibers, but is <em>much</em> simpler to implement.</li>
<li>Node works this way in the lowlevel APIs already, and it&#39;s very ï¬‚exible.</li>
</ul>
<h2 id="callbacks">Callbacks</h2>
<ul>
<li>Simple responders</li>
<li>Must always be prepared to handle errors, that&#39;s why it&#39;s the first argument.</li>
<li>Often inline anonymous, but not always.</li>
<li>Can trap and call other callbacks with modified data, or pass errors upwards.</li>
</ul>
<h2 id="actors">Actors</h2>
<ul>
<li>Last argument is a callback.</li>
<li>If any error occurs, and can&#39;t be handled, pass it to the callback and return.</li>
<li>Must not throw. Return value ignored.</li>
<li>return x ==&gt; return cb(null, x)</li>
<li>throw er ==&gt; return cb(er)</li>
</ul>
<pre><code class="lang-javascript">// return true if a path is either
// a symlink or a directory.
function isLinkOrDir (path, cb) {
  fs.lstat(path, function (er, s) {
    if (er) return cb(er)
    return cb(null, s.isDirectory() || s.isSymbolicLink())
  })
}</code></pre>
<h1 id="asyncmap">asyncMap</h1>
<h2 id="usecases">Usecases</h2>
<ul>
<li>I have a list of 10 files, and need to read all of them, and then continue when they&#39;re all done.</li>
<li>I have a dozen URLs, and need to fetch them all, and then continue when they&#39;re all done.</li>
<li>I have 4 connected users, and need to send a message to all of them, and then continue when that&#39;s done.</li>
<li>I have a list of n things, and I need to dosomething with all of them, in parallel, and get the results once they&#39;re all complete.</li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="lang-javascript">var asyncMap = require(&quot;slide&quot;).asyncMap
function writeFiles (files, what, cb) {
  asyncMap(files, function (f, cb) {
    fs.writeFile(f, what, cb)
  }, cb)
}
writeFiles([my, file, list], &quot;foo&quot;, cb)</code></pre>
<h1 id="chain">chain</h1>
<h2 id="usecases">Usecases</h2>
<ul>
<li>I have to do a bunch of things, in order. Get db credentials out of a file,
read the data from the db, write that data to another file.</li>
<li>If anything fails, do not continue.</li>
<li>I still have to provide an array of functions, which is a lot of boilerplate,
and a pita if your functions take args like</li>
</ul>
<pre><code class="lang-javascript">function (cb) {
  blah(a, b, c, cb)
}</code></pre>
<ul>
<li>Results are discarded, which is a bit lame.</li>
<li>No way to branch.</li>
</ul>
<h2 id="solution">Solution</h2>
<ul>
<li>reduces boilerplate by converting an array of [fn, args] to an actor
that takes no arguments (except cb)</li>
<li>A bit like Function#bind, but tailored for our use-case.</li>
<li>bindActor(obj, &quot;method&quot;, a, b, c)</li>
<li>bindActor(fn, a, b, c)</li>
<li>bindActor(obj, fn, a, b, c)</li>
<li>branching, skipping over falsey arguments</li>
</ul>
<pre><code class="lang-javascript">chain([
  doThing &amp;&amp; [thing, a, b, c]
, isFoo &amp;&amp; [doFoo, &quot;foo&quot;]
, subChain &amp;&amp; [chain, [one, two]]
], cb)</code></pre>
<ul>
<li>tracking results: results are stored in an optional array passed as argument,
last result is always in results[results.length - 1].</li>
<li>treat chain.first and chain.last as placeholders for the first/last
result up until that point.</li>
</ul>
<h2 id="non-trivial-example">Non-trivial example</h2>
<ul>
<li>Read number files in a directory</li>
<li>Add the results together</li>
<li>Ping a web service with the result</li>
<li>Write the response to a file</li>
<li>Delete the number files</li>
</ul>
<pre><code class="lang-javascript">var chain = require(&quot;slide&quot;).chain
function myProgram (cb) {
  var res = [], last = chain.last, first = chain.first
  chain([
    [fs, &quot;readdir&quot;, &quot;the-directory&quot;]
  , [readFiles, &quot;the-directory&quot;, last]
  , [sum, last]
  , [ping, &quot;POST&quot;, &quot;example.com&quot;, 80, &quot;/foo&quot;, last]
  , [fs, &quot;writeFile&quot;, &quot;result.txt&quot;, last]
  , [rmFiles, &quot;./the-directory&quot;, first]
  ], res, cb)
}</code></pre>
<h1 id="conclusion-convention-profits">Conclusion: Convention Profits</h1>
<ul>
<li>Consistent API from top to bottom.</li>
<li>Sneak in at any point to inject functionality. Testable, reusable, ...</li>
<li>When ruby and python users whine, you can smile condescendingly.</li>
</ul>

  </body>
</html>
