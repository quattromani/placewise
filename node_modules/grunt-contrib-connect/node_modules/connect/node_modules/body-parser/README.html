<!DOCTYPE  html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>doc</title>
    <style>
      /*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }
    </style>
  </head>
  <body>  
    <h1 id="body-parser">body-parser</h1>
<p><a href="https://npmjs.org/package/body-parser"><img src="https://img.shields.io/npm/v/body-parser.svg?style=flat" alt="NPM Version"></a>
<a href="https://npmjs.org/package/body-parser"><img src="https://img.shields.io/npm/dm/body-parser.svg?style=flat" alt="NPM Downloads"></a>
<a href="https://travis-ci.org/expressjs/body-parser"><img src="https://img.shields.io/travis/expressjs/body-parser.svg?style=flat" alt="Build Status"></a>
<a href="https://coveralls.io/r/expressjs/body-parser?branch=master"><img src="https://img.shields.io/coveralls/expressjs/body-parser.svg?style=flat" alt="Test Coverage"></a>
<a href="https://www.gratipay.com/dougwilson/"><img src="https://img.shields.io/gratipay/dougwilson.svg?style=flat" alt="Gratipay"></a></p>
<p>Node.js body parsing middleware.</p>
<p>This does not handle multipart bodies, due to their complex and typically large nature. For multipart bodies, you may be interested in the following modules:</p>
<ul>
<li><a href="https://www.npmjs.org/package/busboy#readme">busboy</a> and <a href="https://www.npmjs.org/package/connect-busboy#readme">connect-busboy</a></li>
<li><a href="https://www.npmjs.org/package/multiparty#readme">multiparty</a> and <a href="https://www.npmjs.org/package/connect-multiparty#readme">connect-multiparty</a></li>
<li><a href="https://www.npmjs.org/package/formidable#readme">formidable</a></li>
<li><a href="https://www.npmjs.org/package/multer#readme">multer</a></li>
</ul>
<p>Other body parsers you might be interested in:</p>
<ul>
<li><a href="https://www.npmjs.org/package/body#readme">body</a></li>
<li><a href="https://www.npmjs.org/package/co-body#readme">co-body</a></li>
</ul>
<h2 id="installation">Installation</h2>
<pre><code class="lang-sh">$ npm install body-parser</code></pre>
<h2 id="api">API</h2>
<pre><code class="lang-js">var bodyParser = require(&#39;body-parser&#39;)</code></pre>
<h3 id="bodyparser-json-options-">bodyParser.json(options)</h3>
<p>Returns middleware that only parses <code>json</code>. This parser accepts any Unicode encoding of the body and supports automatic inflation of <code>gzip</code> and <code>deflate</code> encodings.</p>
<p>The options are:</p>
<ul>
<li><code>strict</code> - only parse objects and arrays. (default: <code>true</code>)</li>
<li><code>inflate</code> - if deflated bodies will be inflated. (default: <code>true</code>)</li>
<li><code>limit</code> - maximum request body size. (default: <code>&lt;100kb&gt;</code>)</li>
<li><code>reviver</code> - passed to <code>JSON.parse()</code></li>
<li><code>type</code> - request content-type to parse (default: <code>json</code>)</li>
<li><code>verify</code> - function to verify body content</li>
</ul>
<p>The <code>type</code> argument is passed directly to the <a href="https://www.npmjs.org/package/type-is#readme">type-is</a> library. This can be an extension name (like <code>json</code>), a mime type (like <code>application/json</code>), or a mime time with a wildcard (like <code>*/json</code>).</p>
<p>The <code>verify</code> argument, if supplied, is called as <code>verify(req, res, buf, encoding)</code>, where <code>buf</code> is a <code>Buffer</code> of the raw request body and <code>encoding</code> is the encoding of the request. The parsing can be aborted by throwing an error.</p>
<p>The <code>reviver</code> argument is passed directly to <code>JSON.parse</code> as the second argument. You can find more information on this argument <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter">in the MDN documentation about JSON.parse</a>.</p>
<h3 id="bodyparser-raw-options-">bodyParser.raw(options)</h3>
<p>Returns middleware that parses all bodies as a <code>Buffer</code>. This parser supports automatic inflation of <code>gzip</code> and <code>deflate</code> encodings.</p>
<p>The options are:</p>
<ul>
<li><code>inflate</code> - if deflated bodies will be inflated. (default: <code>true</code>)</li>
<li><code>limit</code> - maximum request body size. (default: <code>&lt;100kb&gt;</code>)</li>
<li><code>type</code> - request content-type to parse (default: <code>application/octet-stream</code>)</li>
<li><code>verify</code> - function to verify body content</li>
</ul>
<p>The <code>type</code> argument is passed directly to the <a href="https://www.npmjs.org/package/type-is#readme">type-is</a> library. This can be an extension name (like <code>bin</code>), a mime type (like <code>application/octet-stream</code>), or a mime time with a wildcard (like <code>application/*</code>).</p>
<p>The <code>verify</code> argument, if supplied, is called as <code>verify(req, res, buf, encoding)</code>, where <code>buf</code> is a <code>Buffer</code> of the raw request body and <code>encoding</code> is the encoding of the request. The parsing can be aborted by throwing an error.</p>
<h3 id="bodyparser-text-options-">bodyParser.text(options)</h3>
<p>Returns middleware that parses all bodies as a string. This parser supports automatic inflation of <code>gzip</code> and <code>deflate</code> encodings.</p>
<p>The options are:</p>
<ul>
<li><code>defaultCharset</code> - the default charset to parse as, if not specified in content-type. (default: <code>utf-8</code>)</li>
<li><code>inflate</code> - if deflated bodies will be inflated. (default: <code>true</code>)</li>
<li><code>limit</code> - maximum request body size. (default: <code>&lt;100kb&gt;</code>)</li>
<li><code>type</code> - request content-type to parse (default: <code>text/plain</code>)</li>
<li><code>verify</code> - function to verify body content</li>
</ul>
<p>The <code>type</code> argument is passed directly to the <a href="https://www.npmjs.org/package/type-is#readme">type-is</a> library. This can be an extension name (like <code>txt</code>), a mime type (like <code>text/plain</code>), or a mime time with a wildcard (like <code>text/*</code>).</p>
<p>The <code>verify</code> argument, if supplied, is called as <code>verify(req, res, buf, encoding)</code>, where <code>buf</code> is a <code>Buffer</code> of the raw request body and <code>encoding</code> is the encoding of the request. The parsing can be aborted by throwing an error.</p>
<h3 id="bodyparser-urlencoded-options-">bodyParser.urlencoded(options)</h3>
<p>Returns middleware that only parses <code>urlencoded</code> bodies. This parser accepts only UTF-8 encoding of the body and supports automatic inflation of <code>gzip</code> and <code>deflate</code> encodings.</p>
<p>The options are:</p>
<ul>
<li><code>extended</code> - parse extended syntax with the <a href="https://www.npmjs.org/package/qs#readme">qs</a> module. (default: <code>true</code>, but using the default has been deprecated. Please research into the difference between <code>qs</code> and <code>querystring</code> and choose the appropriate setting)</li>
<li><code>inflate</code> - if deflated bodies will be inflated. (default: <code>true</code>)</li>
<li><code>limit</code> - maximum request body size. (default: <code>&lt;100kb&gt;</code>)</li>
<li><code>parameterLimit</code> - maximum number of parameters. (default: <code>1000</code>)</li>
<li><code>type</code> - request content-type to parse (default: <code>urlencoded</code>)</li>
<li><code>verify</code> - function to verify body content</li>
</ul>
<p>The <code>extended</code> argument allows to choose between parsing the urlencoded data with the <code>querystring</code> library (when <code>false</code>) or the <code>qs</code> library (when <code>true</code>). The &quot;extended&quot; syntax allows for rich objects and arrays to be encoded into the urlencoded format, allowing for a JSON-like experience with urlencoded. For more information, please <a href="https://www.npmjs.org/package/qs#readme">see the qs library</a>.</p>
<p>The <code>parameterLimit</code> argument controls the maximum number of parameters that are allowed in the urlencoded data. If a request contains more parameters than this value, a 413 will be returned to the client.</p>
<p>The <code>type</code> argument is passed directly to the <a href="https://www.npmjs.org/package/type-is#readme">type-is</a> library. This can be an extension name (like <code>urlencoded</code>), a mime type (like <code>application/x-www-form-urlencoded</code>), or a mime time with a wildcard (like <code>*/x-www-form-urlencoded</code>).</p>
<p>The <code>verify</code> argument, if supplied, is called as <code>verify(req, res, buf, encoding)</code>, where <code>buf</code> is a <code>Buffer</code> of the raw request body and <code>encoding</code> is the encoding of the request. The parsing can be aborted by throwing an error.</p>
<h3 id="req-body">req.body</h3>
<p>A new <code>body</code> object containing the parsed data is populated on the <code>request</code> object after the middleware.</p>
<h2 id="examples">Examples</h2>
<h3 id="express-connect-top-level-generic">express/connect top-level generic</h3>
<p>This example demonstrates adding a generic JSON and urlencoded parser as a top-level middleware, which will parse the bodies of all incoming requests. This is the simplest setup.</p>
<pre><code class="lang-js">var express = require(&#39;express&#39;)
var bodyParser = require(&#39;body-parser&#39;)

var app = express()

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))

// parse application/json
app.use(bodyParser.json())

app.use(function (req, res) {
  res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;)
  res.write(&#39;you posted:\n&#39;)
  res.end(JSON.stringify(req.body, null, 2))
})</code></pre>
<h3 id="express-route-specific">express route-specific</h3>
<p>This example demonstrates adding body parsers specifically to the routes that need them. In general, this is the most recommend way to use body-parser with express.</p>
<pre><code class="lang-js">var express = require(&#39;express&#39;)
var bodyParser = require(&#39;body-parser&#39;)

var app = express()

// create application/json parser
var jsonParser = bodyParser.json()

// create application/x-www-form-urlencoded parser
var urlencodedParser = bodyParser.urlencoded({ extended: false })

// POST /login gets urlencoded bodies
app.post(&#39;/login&#39;, urlencodedParser, function (req, res) {
  if (!req.body) return res.sendStatus(400)
  res.send(&#39;welcome, &#39; + res.body.username)
})

// POST /api/users gets JSON bodies
app.post(&#39;/api/users&#39;, jsonParser, function (req, res) {
  if (!req.body) return res.sendStatus(400)
  // create user in req.body
})</code></pre>
<h3 id="change-content-type-for-parsers">change content-type for parsers</h3>
<p>All the parsers accept a <code>type</code> option which allows you to change the <code>Content-Type</code> that the middleware will parse.</p>
<pre><code class="lang-js">// parse various different custom JSON types as JSON
app.use(bodyParser.json({ type: &#39;application/*+json&#39; }))

// parse some custom thing into a Buffer
app.use(bodyParser.raw({ type: &#39;application/vnd.custom-type&#39; }))

// parse an HTML body into a string
app.use(bodyParser.text({ type: &#39;text/html&#39; }))</code></pre>
<h2 id="license">License</h2>
<p><a href="LICENSE">MIT</a></p>

  </body>
</html>
