<!DOCTYPE  html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>doc</title>
    <style>
      /*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }
    </style>
  </head>
  <body>  
    <h1 id="multiparty-build-status-https-travis-ci-org-andrewrk-node-multiparty-svg-branch-master-https-travis-ci-org-andrewrk-node-multiparty-npm-version-https-badge-fury-io-js-multiparty-svg-http-badge-fury-io-js-multiparty-">multiparty <a href="https://travis-ci.org/andrewrk/node-multiparty"><img src="https://travis-ci.org/andrewrk/node-multiparty.svg?branch=master" alt="Build Status"></a> <a href="http://badge.fury.io/js/multiparty"><img src="https://badge.fury.io/js/multiparty.svg" alt="NPM version"></a></h1>
<p>Parse http requests with content-type <code>multipart/form-data</code>, also known as file uploads.</p>
<p>See also <a href="https://github.com/mscdex/busboy">busboy</a> - a
<a href="https://github.com/mscdex/dicer/wiki/Benchmarks">faster</a> alternative
which may be worth looking into.</p>
<h3 id="why-the-fork-">Why the fork?</h3>
<ul>
<li>This module uses the Node.js v0.10 streams properly, <em>even in Node.js v0.8</em></li>
<li>It will not create a temp file for you unless you want it to.</li>
<li>Counts bytes and does math to help you figure out the <code>Content-Length</code> of
each part.</li>
<li>You can easily stream uploads to s3 with
<a href="https://github.com/LearnBoost/knox">knox</a>, for <a href="examples/s3.js">example</a>.</li>
<li>Less bugs. This code is simpler, has all deprecated functionality removed,
has cleaner tests, and does not try to do anything beyond multipart stream
parsing.</li>
</ul>
<h2 id="installation">Installation</h2>
<pre><code>npm install multiparty</code></pre>
<h2 id="usage">Usage</h2>
<ul>
<li>See <a href="examples">examples</a>.</li>
</ul>
<p>Parse an incoming <code>multipart/form-data</code> request.</p>
<pre><code class="lang-js">var multiparty = require(&#39;multiparty&#39;)
  , http = require(&#39;http&#39;)
  , util = require(&#39;util&#39;)

http.createServer(function(req, res) {
  if (req.url === &#39;/upload&#39; &amp;&amp; req.method === &#39;POST&#39;) {
    // parse a file upload
    var form = new multiparty.Form();

    form.parse(req, function(err, fields, files) {
      res.writeHead(200, {&#39;content-type&#39;: &#39;text/plain&#39;});
      res.write(&#39;received upload:\n\n&#39;);
      res.end(util.inspect({fields: fields, files: files}));
    });

    return;
  }

  // show a file upload form
  res.writeHead(200, {&#39;content-type&#39;: &#39;text/html&#39;});
  res.end(
    &#39;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;&#39;+
    &#39;&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;&lt;br&gt;&#39;+
    &#39;&lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt;&lt;br&gt;&#39;+
    &#39;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;&#39;+
    &#39;&lt;/form&gt;&#39;
  );
}).listen(8080);</code></pre>
<h2 id="api">API</h2>
<h3 id="multiparty-form">multiparty.Form</h3>
<pre><code class="lang-js">var form = new multiparty.Form(options)</code></pre>
<p>Creates a new form. Options:</p>
<ul>
<li><code>encoding</code> - sets encoding for the incoming form fields. Defaults to <code>utf8</code>.</li>
<li><code>maxFieldsSize</code> - Limits the amount of memory a field (not a file) can
allocate in bytes. If this value is exceeded, an <code>error</code> event is emitted.
The default size is 2MB.</li>
<li><code>maxFields</code> - Limits the number of fields that will be parsed before
emitting an <code>error</code> event. A file counts as a field in this case.
Defaults to 1000.</li>
<li><code>maxFilesSize</code> - Only relevant when <code>autoFiles</code> is <code>true</code>.  Limits the
total bytes accepted for all files combined. If this value is exceeded,
an <code>error</code> event is emitted. The default is <code>Infinity</code>.</li>
<li><code>autoFields</code> - Enables <code>field</code> events. This is automatically set to <code>true</code>
if you add a <code>field</code> listener.</li>
<li><code>autoFiles</code> - Enables <code>file</code> events. This is automatically set to <code>true</code>
if you add a <code>file</code> listener.</li>
<li><code>uploadDir</code> - Only relevant when <code>autoFiles</code> is <code>true</code>. The directory for
placing file uploads in. You can move them later using <code>fs.rename()</code>.
Defaults to <code>os.tmpDir()</code>.</li>
<li><code>hash</code> - Only relevant when <code>autoFiles</code> is <code>true</code>. If you want checksums
calculated for incoming files, set this to either <code>sha1</code> or <code>md5</code>.
Defaults to off.</li>
</ul>
<h4 id="form-parse-request-cb-">form.parse(request, [cb])</h4>
<p>Parses an incoming node.js <code>request</code> containing form data.This will cause
<code>form</code> to emit events based off the incoming request.</p>
<pre><code class="lang-js">var count = 0;
var form = new multiparty.Form();

// Errors may be emitted
form.on(&#39;error&#39;, function(err) {
  console.log(&#39;Error parsing form: &#39; + err.stack);
});

// Parts are emitted when parsing the form
form.on(&#39;part&#39;, function(part) {
  // You *must* act on the part by reading it
  // NOTE: if you want to ignore it, just call &quot;part.resume()&quot;

  if (part.filename === null) {
    // filename is &quot;null&quot; when this is a field and not a file
    console.log(&#39;got field named &#39; + part.name);
    // ignore field&#39;s content
    part.resume();
  }

  if (part.filename !== null) {
    // filename is not &quot;null&quot; when this is a file
    count++;
    console.log(&#39;got file named &#39; + part.name);
    // ignore file&#39;s content here
    part.resume();
  }
});

// Close emitted after form parsed
form.on(&#39;close&#39;, function() {
  console.log(&#39;Upload completed!&#39;);
  res.setHeader(&#39;text/plain&#39;);
  res.end(&#39;Received &#39; + count + &#39; files&#39;);
});

// Parse req
form.parse(req);</code></pre>
<p>If <code>cb</code> is provided, <code>autoFields</code> and <code>autoFiles</code> are set to <code>true</code> and all
fields and files are collected and passed to the callback, removing the need to
listen to any events on <code>form</code>. This is for convenience when wanted to read
everything, but be careful as this will write all uploaded files to the disk,
even ones you may not be interested in.</p>
<pre><code class="lang-js">form.parse(req, function(err, fields, files) {
  Object.keys(fields).forEach(function(name) {
    console.log(&#39;got field named &#39; + name);
  });

  Object.keys(files).forEach(function(name) {
    console.log(&#39;got file named &#39; + name);
  });

  console.log(&#39;Upload completed!&#39;);
  res.setHeader(&#39;text/plain&#39;);
  res.end(&#39;Received &#39; + files.length + &#39; files&#39;);
});</code></pre>
<p><code>fields</code> is an object where the property names are field names and the values
are arrays of field values.</p>
<p><code>files</code> is an object where the property names are field names and the values
are arrays of file objects.</p>
<h4 id="form-bytesreceived">form.bytesReceived</h4>
<p>The amount of bytes received for this form so far.</p>
<h4 id="form-bytesexpected">form.bytesExpected</h4>
<p>The expected number of bytes in this form.</p>
<h3 id="events">Events</h3>
<h4 id="-error-err-">&#39;error&#39; (err)</h4>
<p>Unless you supply a callback to <code>form.parse</code>, you definitely want to handle
this event. Otherwise your server <em>will</em> crash when users submit bogus
multipart requests!</p>
<p>Only one &#39;error&#39; event can ever be emitted, and if an &#39;error&#39; event is
emitted, then &#39;close&#39; will not be emitted.</p>
<h4 id="-part-part-">&#39;part&#39; (part)</h4>
<p>Emitted when a part is encountered in the request. <code>part</code> is a
<code>ReadableStream</code>. It also has the following properties:</p>
<ul>
<li><code>headers</code> - the headers for this part. For example, you may be interested
in <code>content-type</code>.</li>
<li><code>name</code> - the field name for this part</li>
<li><code>filename</code> - only if the part is an incoming file</li>
<li><code>byteOffset</code> - the byte offset of this part in the request body</li>
<li><code>byteCount</code> - assuming that this is the last part in the request,
this is the size of this part in bytes. You could use this, for
example, to set the <code>Content-Length</code> header if uploading to S3.
If the part had a <code>Content-Length</code> header then that value is used
here instead.</li>
</ul>
<h4 id="-aborted-">&#39;aborted&#39;</h4>
<p>Emitted when the request is aborted. This event will be followed shortly
by an <code>error</code> event. In practice you do not need to handle this event.</p>
<h4 id="-progress-bytesreceived-bytesexpected-">&#39;progress&#39; (bytesReceived, bytesExpected)</h4>
<h4 id="-close-">&#39;close&#39;</h4>
<p>Emitted after all parts have been parsed and emitted. Not emitted if an <code>error</code>
event is emitted. This is typically when you would send your response.</p>
<h4 id="-file-name-file-">&#39;file&#39; (name, file)</h4>
<p><strong>By default multiparty will not touch your hard drive.</strong> But if you add this
listener, multiparty automatically sets <code>form.autoFiles</code> to <code>true</code> and will
stream uploads to disk for you. </p>
<p><strong>The max bytes accepted per request can be specified with <code>maxFilesSize</code>.</strong></p>
<ul>
<li><code>name</code> - the field name for this file</li>
<li><code>file</code> - an object with these properties:<ul>
<li><code>fieldName</code> - same as <code>name</code> - the field name for this file</li>
<li><code>originalFilename</code> - the filename that the user reports for the file</li>
<li><code>path</code> - the absolute path of the uploaded file on disk</li>
<li><code>headers</code> - the HTTP headers that were sent along with this file</li>
<li><code>size</code> - size of the file in bytes</li>
</ul>
</li>
</ul>
<p>If you set the <code>form.hash</code> option, then <code>file</code> will also contain a <code>hash</code>
property which is the checksum of the file.</p>
<h4 id="-field-name-value-">&#39;field&#39; (name, value)</h4>
<ul>
<li><code>name</code> - field name</li>
<li><code>value</code> - string field value</li>
</ul>

  </body>
</html>
