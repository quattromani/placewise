<!DOCTYPE  html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>doc</title>
    <style>
      /*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }
    </style>
  </head>
  <body>  
    <h1 id="through2">through2</h1>
<!--

soon ...

[![Build Status](https://secure.travis-ci.org/rvagg/through2.png)](http://travis-ci.org/rvagg/through2)

[![Build Status](https://saucelabs.com/browser-matrix/through2-sauce.svg)](https://travis-ci.org/rvagg/through2)

-->

<p><a href="https://nodei.co/npm/through2/"><img src="https://nodei.co/npm/through2.png?compact=true" alt="NPM"></a></p>
<!--
not happy with these, we need to peg to readable-stream@1.0.x so it'll always report out-of-date

[![david-dm](https://david-dm.org/rvagg/through2.png)](https://david-dm.org/rvagg/through2/)
[![david-dm](https://david-dm.org/rvagg/through2/dev-status.png)](https://david-dm.org/rvagg/through2#info=devDependencies/)
-->

<p><strong>A tiny wrapper around Node streams.Transform (Streams2) to avoid explicit subclassing noise</strong></p>
<p>Inspired by <a href="https://github.com/dominictarr">Dominic Tarr</a>&#39;s <a href="https://github.com/dominictarr/through">through</a> in that it&#39;s so much easier to make a stream out of a function than it is to set up the prototype chain properly: <code>through(function (chunk) { ... })</code>.</p>
<p>Note: A <strong>Streams3</strong> version of through2 is available in npm with the tag <code>&quot;1.0&quot;</code> rather than <code>&quot;latest&quot;</code> so an <code>npm install through2</code> will get you the current Streams2 version (version number is 0.x.x). To use a Streams3 version use <code>npm install through2@1</code> to fetch the latest version 1.x.x. More information about Streams2 vs Streams3 and recommendations <a href="http://www.nearform.com/nodecrunch/dont-use-nodes-core-stream-module">here</a>.</p>
<pre><code class="lang-js">fs.createReadStream(&#39;ex.txt&#39;)
  .pipe(through2(function (chunk, enc, callback) {

    for (var i = 0; i &lt; chunk.length; i++)
      if (chunk[i] == 97)
        chunk[i] = 122 // swap &#39;a&#39; for &#39;z&#39;

    this.push(chunk)

    callback()

   }))
  .pipe(fs.createWriteStream(&#39;out.txt&#39;))</code></pre>
<p>Or object streams:</p>
<pre><code class="lang-js">var all = []

fs.createReadStream(&#39;data.csv&#39;)
  .pipe(csv2())
  .pipe(through2.obj(function (chunk, enc, callback) {

    var data = {
        name    : chunk[0]
      , address : chunk[3]
      , phone   : chunk[10]
    }

    this.push(data)

    callback()

  }))
  .on(&#39;data&#39;, function (data) {
    all.push(data)
  })
  .on(&#39;end&#39;, function () {
    doSomethingSpecial(all)
  })</code></pre>
<p>Note that <code>through2.obj(fn)</code> is a convenience wrapper around <code>through2({ objectMode: true }, fn)</code>.</p>
<h2 id="api">API</h2>
<p><b><code>through2([ options, ] [ transformFunction ] [, flushFunction ])</code></b></p>
<p>Consult the <strong><a href="http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_transform">stream.Transform</a></strong> documentation for the exact rules of the <code>transformFunction</code> (i.e. <code>this._transform</code>) and the optional <code>flushFunction</code> (i.e. <code>this._flush</code>).</p>
<h3 id="options">options</h3>
<p>The options argument is optional and is passed straight through to <code>stream.Transform</code>. So you can use <code>objectMode:true</code> if you are processing non-binary streams (or just use <code>through2.obj()</code>).</p>
<p>The <code>options</code> argument is first, unlike standard convention, because if I&#39;m passing in an anonymous function then I&#39;d prefer for the options argument to not get lost at the end of the call:</p>
<pre><code class="lang-js">fs.createReadStream(&#39;/tmp/important.dat&#39;)
  .pipe(through2({ objectMode: true, allowHalfOpen: false }, function (chunk, enc, cb) {

    this.push(new Buffer(&#39;wut?&#39;))
    cb()

  })
  .pipe(fs.createWriteStream(&#39;/tmp/wut.txt&#39;))</code></pre>
<h3 id="transformfunction">transformFunction</h3>
<p>The <code>transformFunction</code> must have the following signature: <code>function (chunk, encoding, callback) {}</code>. A minimal implementation should call the <code>callback</code> function to indicate that the transformation is done, even if that transformation means discarding the chunk.</p>
<p>To queue a new chunk, call <code>this.push(chunk)</code>&mdash;this can be called as many times as required before the <code>callback()</code> if you have multiple pieces to send on.</p>
<p>Alternatively, you may use <code>callback(err, chunk)</code> as shorthand for emitting a single chunk or an error.</p>
<p>If you <strong>do not provide a <code>transformFunction</code></strong> then you will get a simple pass-through stream.</p>
<h3 id="flushfunction">flushFunction</h3>
<p>The optional <code>flushFunction</code> is provided as the last argument (2nd or 3rd, depending on whether you&#39;ve supplied options) is called just prior to the stream ending. Can be used to finish up any processing that may be in progress.</p>
<p><b><code>through2.ctor([ options, ] transformFunction[, flushFunction ])</code></b></p>
<p>Instead of returning a <code>stream.Transform</code> instance, <code>through2.ctor()</code> returns a <strong>constructor</strong> for a custom Transform. This is useful when you want to use the same transform logic in multiple instances.</p>
<pre><code class="lang-js">var FToC = through2.ctor({objectMode: true}, function (record, encoding, callback) {
  if (record.temp != null &amp;&amp; record.unit = &quot;F&quot;) {
    record.temp = ( ( record.temp - 32 ) * 5 ) / 9
    record.unit = &quot;C&quot;
  }
  this.push(record)
  callback()
})

// Create instances of FToC like so:
var converter = new FToC()
// Or:
var converter = FToC()
// Or specify/override options when you instantiate, if you prefer:
var converter = FToC({objectMode: true})</code></pre>
<h2 id="see-also">See Also</h2>
<ul>
<li><a href="https://github.com/brycebaril/through2-map">through2-map</a> - Array.prototype.map analog for streams.</li>
<li><a href="https://github.com/brycebaril/through2-filter">through2-filter</a> - Array.prototype.filter analog for streams.</li>
<li><a href="https://github.com/brycebaril/through2-reduce">through2-reduce</a> - Array.prototype.reduce analog for streams.</li>
<li><a href="https://github.com/brycebaril/through2-spy">through2-spy</a> - Wrapper for simple stream.PassThrough spies.</li>
</ul>
<h2 id="license">License</h2>
<p><strong>through2</strong> is Copyright (c) 2013 Rod Vagg <a href="https://twitter.com/rvagg">@rvagg</a> and licenced under the MIT licence. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.</p>

  </body>
</html>
