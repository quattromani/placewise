<!DOCTYPE  html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>doc</title>
    <style>
      /*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }
    </style>
  </head>
  <body>  
    <h1 id="request-simplified-http-client">Request — Simplified HTTP client</h1>
<p><a href="https://nodei.co/npm/request/"><img src="https://nodei.co/npm/request.png?downloads=true&amp;downloadRank=true&amp;stars=true" alt="NPM"></a></p>
<p><a href="https://gitter.im/request/request?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join Chat.svg" alt="Gitter"></a></p>
<h2 id="super-simple-to-use">Super simple to use</h2>
<p>Request is designed to be the simplest way possible to make http calls. It supports HTTPS and follows redirects by default.</p>
<pre><code class="lang-javascript">var request = require(&#39;request&#39;);
request(&#39;http://www.google.com&#39;, function (error, response, body) {
  if (!error &amp;&amp; response.statusCode == 200) {
    console.log(body) // Print the google web page.
  }
})</code></pre>
<h2 id="streaming">Streaming</h2>
<p>You can stream any response to a file stream.</p>
<pre><code class="lang-javascript">request(&#39;http://google.com/doodle.png&#39;).pipe(fs.createWriteStream(&#39;doodle.png&#39;))</code></pre>
<p>You can also stream a file to a PUT or POST request. This method will also check the file extension against a mapping of file extensions to content-types (in this case <code>application/json</code>) and use the proper <code>content-type</code> in the PUT request (if the headers don’t already provide one).</p>
<pre><code class="lang-javascript">fs.createReadStream(&#39;file.json&#39;).pipe(request.put(&#39;http://mysite.com/obj.json&#39;))</code></pre>
<p>Request can also <code>pipe</code> to itself. When doing so, <code>content-type</code> and <code>content-length</code> are preserved in the PUT headers.</p>
<pre><code class="lang-javascript">request.get(&#39;http://google.com/img.png&#39;).pipe(request.put(&#39;http://mysite.com/img.png&#39;))</code></pre>
<p>Request emits a &quot;response&quot; event when a response is received. The <code>response</code> argument will be an instance of <a href="http://nodejs.org/api/http.html#http_http_incomingmessage">http.IncomingMessage</a>.</p>
<pre><code class="lang-javascript">request
  .get(&#39;http://google.com/img.png&#39;)
  .on(&#39;response&#39;, function(response) {
    console.log(response.statusCode) // 200
    console.log(response.headers[&#39;content-type&#39;]) // &#39;image/png&#39;
  })
  .pipe(request.put(&#39;http://mysite.com/img.png&#39;))</code></pre>
<p>To easily handle errors when streaming requests, listen to the <code>error</code> event before piping:</p>
<pre><code class="lang-javascript">request
  .get(&#39;http://mysite.com/doodle.png&#39;)
  .on(&#39;error&#39;, function(err) {
    console.log(err)
  })
  .pipe(fs.createWriteStream(&#39;doodle.png&#39;))</code></pre>
<p>Now let’s get fancy.</p>
<pre><code class="lang-javascript">http.createServer(function (req, resp) {
  if (req.url === &#39;/doodle.png&#39;) {
    if (req.method === &#39;PUT&#39;) {
      req.pipe(request.put(&#39;http://mysite.com/doodle.png&#39;))
    } else if (req.method === &#39;GET&#39; || req.method === &#39;HEAD&#39;) {
      request.get(&#39;http://mysite.com/doodle.png&#39;).pipe(resp)
    }
  }
})</code></pre>
<p>You can also <code>pipe()</code> from <code>http.ServerRequest</code> instances, as well as to <code>http.ServerResponse</code> instances. The HTTP method, headers, and entity-body data will be sent. Which means that, if you don&#39;t really care about security, you can do:</p>
<pre><code class="lang-javascript">http.createServer(function (req, resp) {
  if (req.url === &#39;/doodle.png&#39;) {
    var x = request(&#39;http://mysite.com/doodle.png&#39;)
    req.pipe(x)
    x.pipe(resp)
  }
})</code></pre>
<p>And since <code>pipe()</code> returns the destination stream in ≥ Node 0.5.x you can do one line proxying. :)</p>
<pre><code class="lang-javascript">req.pipe(request(&#39;http://mysite.com/doodle.png&#39;)).pipe(resp)</code></pre>
<p>Also, none of this new functionality conflicts with requests previous features, it just expands them.</p>
<pre><code class="lang-javascript">var r = request.defaults({&#39;proxy&#39;:&#39;http://localproxy.com&#39;})

http.createServer(function (req, resp) {
  if (req.url === &#39;/doodle.png&#39;) {
    r.get(&#39;http://google.com/doodle.png&#39;).pipe(resp)
  }
})</code></pre>
<p>You can still use intermediate proxies, the requests will still follow HTTP forwards, etc.</p>
<h2 id="proxies">Proxies</h2>
<p>If you specify a <code>proxy</code> option, then the request (and any subsequent
redirects) will be sent via a connection to the proxy server.</p>
<p>If your endpoint is an <code>https</code> url, and you are using a proxy, then
request will send a <code>CONNECT</code> request to the proxy server <em>first</em>, and
then use the supplied connection to connect to the endpoint.</p>
<p>That is, first it will make a request like:</p>
<pre><code>HTTP/1.1 CONNECT endpoint-server.com:80
Host: proxy-server.com
User-Agent: whatever user agent you specify</code></pre>
<p>and then the proxy server make a TCP connection to <code>endpoint-server</code>
on port <code>80</code>, and return a response that looks like:</p>
<pre><code>HTTP/1.1 200 OK</code></pre>
<p>At this point, the connection is left open, and the client is
communicating directly with the <code>endpoint-server.com</code> machine.</p>
<p>See <a href="http://en.wikipedia.org/wiki/HTTP_tunnel">the wikipedia page on HTTP Tunneling</a>
for more information.</p>
<p>By default, when proxying <code>http</code> traffic, request will simply make a
standard proxied <code>http</code> request.  This is done by making the <code>url</code>
section of the initial line of the request a fully qualified url to
the endpoint.</p>
<p>For example, it will make a single request that looks like:</p>
<pre><code>HTTP/1.1 GET http://endpoint-server.com/some-url
Host: proxy-server.com
Other-Headers: all go here

request body or whatever</code></pre>
<p>Because a pure &quot;http over http&quot; tunnel offers no additional security
or other features, it is generally simpler to go with a
straightforward HTTP proxy in this case.  However, if you would like
to force a tunneling proxy, you may set the <code>tunnel</code> option to <code>true</code>.</p>
<p>If you are using a tunneling proxy, you may set the
<code>proxyHeaderWhiteList</code> to share certain headers with the proxy.</p>
<p>You can also set the <code>proxyHeaderExclusiveList</code> to share certain
headers only with the proxy and not with destination host.</p>
<p>By default, this set is:</p>
<pre><code>accept
accept-charset
accept-encoding
accept-language
accept-ranges
cache-control
content-encoding
content-language
content-length
content-location
content-md5
content-range
content-type
connection
date
expect
max-forwards
pragma
proxy-authorization
referer
te
transfer-encoding
user-agent
via</code></pre>
<p>Note that, when using a tunneling proxy, the <code>proxy-authorization</code>
header and any headers from custom <code>proxyHeaderExclusiveList</code> are
<em>never</em> sent to the endpoint server, but only to the proxy server.</p>
<h3 id="controlling-proxy-behaviour-using-environment-variables">Controlling proxy behaviour using environment variables</h3>
<p>The following environment variables are respected by <code>request</code>:</p>
<ul>
<li><code>HTTP_PROXY</code> / <code>http_proxy</code></li>
<li><code>HTTPS_PROXY</code> / <code>https_proxy</code></li>
<li><code>NO_PROXY</code> / <code>no_proxy</code></li>
</ul>
<p>When <code>HTTP_PROXY</code> / <code>http_proxy</code> are set, they will be used to proxy non-SSL requests that do not have an explicit <code>proxy</code> configuration option present. Similarly, <code>HTTPS_PROXY</code> / <code>https_proxy</code> will be respected for SSL requests that do not have an explicit <code>proxy</code> configuration option. It is valid to define a proxy in one of the environment variables, but then override it for a specific request, using the <code>proxy</code> configuration option. Furthermore, the <code>proxy</code> configuration option can be explicitly set to false / null to opt out of proxying altogether for that request.</p>
<p><code>request</code> is also aware of the <code>NO_PROXY</code>/<code>no_proxy</code> environment variables. These variables provide a granular way to opt out of proxying, on a per-host basis. It should contain a comma separated list of hosts to opt out of proxying. It is also possible to opt of proxying when a particular destination port is used. Finally, the variable may be set to <code>*</code> to opt out of the implicit proxy configuration of the other environment variables.</p>
<p>Here&#39;s some examples of valid <code>no_proxy</code> values:</p>
<ul>
<li><code>google.com</code> - don&#39;t proxy HTTP/HTTPS requests to Google.</li>
<li><code>google.com:443</code> - don&#39;t proxy HTTPS requests to Google, but <em>do</em> proxy HTTP requests to Google.</li>
<li><code>google.com:443, yahoo.com:80</code> - don&#39;t proxy HTTPS requests to Google, and don&#39;t proxy HTTP requests to Yahoo!</li>
<li><code>*</code> - ignore <code>https_proxy</code>/<code>http_proxy</code> environment variables altogether.</li>
</ul>
<h2 id="unix-socket">UNIX Socket</h2>
<p><code>request</code> supports making requests to <a href="http://en.wikipedia.org/wiki/Unix_domain_socket">UNIX Domain Sockets</a>. To make one, use the following URL scheme:</p>
<pre><code class="lang-javascript">/* Pattern */ &#39;http://unix:SOCKET:PATH&#39;
/* Example */ request.get(&#39;http://unix:/absolute/path/to/unix.socket:/request/path&#39;)</code></pre>
<p>Note: The <code>SOCKET</code> path is assumed to be absolute to the root of the host file system.</p>
<h2 id="forms">Forms</h2>
<p><code>request</code> supports <code>application/x-www-form-urlencoded</code> and <code>multipart/form-data</code> form uploads. For <code>multipart/related</code> refer to the <code>multipart</code> API.</p>
<h4 id="application-x-www-form-urlencoded-url-encoded-forms-">application/x-www-form-urlencoded (URL-Encoded Forms)</h4>
<p>URL-encoded forms are simple.</p>
<pre><code class="lang-javascript">request.post(&#39;http://service.com/upload&#39;, {form:{key:&#39;value&#39;}})
// or
request.post(&#39;http://service.com/upload&#39;).form({key:&#39;value&#39;})
// or
request.post({url:&#39;http://service.com/upload&#39;, form: {key:&#39;value&#39;}}, function(err,httpResponse,body){ /* ... */ })</code></pre>
<h4 id="multipart-form-data-multipart-form-uploads-">multipart/form-data (Multipart Form Uploads)</h4>
<p>For <code>multipart/form-data</code> we use the <a href="https://github.com/felixge/node-form-data">form-data</a> library by <a href="https://github.com/felixge">@felixge</a>. For the most cases, you can pass your upload form data via the <code>formData</code> option.</p>
<pre><code class="lang-javascript">var formData = {
  // Pass a simple key-value pair
  my_field: &#39;my_value&#39;,
  // Pass data via Buffers
  my_buffer: new Buffer([1, 2, 3]),
  // Pass data via Streams
  my_file: fs.createReadStream(__dirname + &#39;/unicycle.jpg&#39;),
  // Pass multiple values /w an Array
  attachments: [
    fs.createReadStream(__dirname + &#39;/attachment1.jpg&#39;),
    fs.createReadStream(__dirname + &#39;/attachment2.jpg&#39;)
  ],
  // Pass optional meta-data with an &#39;options&#39; object with style: {value: DATA, options: OPTIONS}
  // Use case: for some types of streams, you&#39;ll need to provide &quot;file&quot;-related information manually.
  // See the `form-data` README for more information about options: https://github.com/felixge/node-form-data
  custom_file: {
    value:  fs.createReadStream(&#39;/dev/urandom&#39;),
    options: {
      filename: &#39;topsecret.jpg&#39;,
      contentType: &#39;image/jpg&#39;
    }
  }
};
request.post({url:&#39;http://service.com/upload&#39;, formData: formData}, function optionalCallback(err, httpResponse, body) {
  if (err) {
    return console.error(&#39;upload failed:&#39;, err);
  }
  console.log(&#39;Upload successful!  Server responded with:&#39;, body);
});</code></pre>
<p>For advanced cases, you can access the form-data object itself via <code>r.form()</code>. This can be modified until the request is fired on the next cycle of the event-loop. (Note that this calling <code>form()</code> will clear the currently set form data for that request.)</p>
<pre><code class="lang-javascript">// NOTE: Advanced use-case, for normal use see &#39;formData&#39; usage above
var r = request.post(&#39;http://service.com/upload&#39;, function optionalCallback(err, httpResponse, body) { // ...

var form = r.form();
form.append(&#39;my_field&#39;, &#39;my_value&#39;);
form.append(&#39;my_buffer&#39;, new Buffer([1, 2, 3]));
form.append(&#39;custom_file&#39;, fs.createReadStream(__dirname + &#39;/unicycle.jpg&#39;), {filename: &#39;unicycle.jpg&#39;});</code></pre>
<p>See the <a href="https://github.com/felixge/node-form-data">form-data README</a> for more information &amp; examples.</p>
<h4 id="multipart-related">multipart/related</h4>
<p>Some variations in different HTTP implementations require a newline/CRLF before, after, or both before and after the boundary of a <code>multipart/related</code> request (using the multipart option). This has been observed in the .NET WebAPI version 4.0. You can turn on a boundary preambleCRLF or postamble by passing them as <code>true</code> to your request options.</p>
<pre><code class="lang-javascript">  request({
    method: &#39;PUT&#39;,
    preambleCRLF: true,
    postambleCRLF: true,
    uri: &#39;http://service.com/upload&#39;,
    multipart: [
      {
        &#39;content-type&#39;: &#39;application/json&#39;
        body: JSON.stringify({foo: &#39;bar&#39;, _attachments: {&#39;message.txt&#39;: {follows: true, length: 18, &#39;content_type&#39;: &#39;text/plain&#39; }}})
      },
      { body: &#39;I am an attachment&#39; },
      { body: fs.createReadStream(&#39;image.png&#39;) }
    ],
    // alternatively pass an object containing additional options
    multipart: {
      chunked: false,
      data: [
        {
          &#39;content-type&#39;: &#39;application/json&#39;,
          body: JSON.stringify({foo: &#39;bar&#39;, _attachments: {&#39;message.txt&#39;: {follows: true, length: 18, &#39;content_type&#39;: &#39;text/plain&#39; }}})
        },
        { body: &#39;I am an attachment&#39; }
      ]
    }
  },
  function (error, response, body) {
    if (error) {
      return console.error(&#39;upload failed:&#39;, error);
    }
    console.log(&#39;Upload successful!  Server responded with:&#39;, body);
  })</code></pre>
<h2 id="http-authentication">HTTP Authentication</h2>
<pre><code class="lang-javascript">request.get(&#39;http://some.server.com/&#39;).auth(&#39;username&#39;, &#39;password&#39;, false);
// or
request.get(&#39;http://some.server.com/&#39;, {
  &#39;auth&#39;: {
    &#39;user&#39;: &#39;username&#39;,
    &#39;pass&#39;: &#39;password&#39;,
    &#39;sendImmediately&#39;: false
  }
});
// or
request.get(&#39;http://some.server.com/&#39;).auth(null, null, true, &#39;bearerToken&#39;);
// or
request.get(&#39;http://some.server.com/&#39;, {
  &#39;auth&#39;: {
    &#39;bearer&#39;: &#39;bearerToken&#39;
  }
});</code></pre>
<p>If passed as an option, <code>auth</code> should be a hash containing values <code>user</code> || <code>username</code>, <code>pass</code> || <code>password</code>, and <code>sendImmediately</code> (optional).  The method form takes parameters <code>auth(username, password, sendImmediately)</code>.</p>
<p><code>sendImmediately</code> defaults to <code>true</code>, which causes a basic authentication header to be sent.  If <code>sendImmediately</code> is <code>false</code>, then <code>request</code> will retry with a proper authentication header after receiving a <code>401</code> response from the server (which must contain a <code>WWW-Authenticate</code> header indicating the required authentication method).</p>
<p>Note that you can also use for basic authentication a trick using the URL itself, as specified in <a href="http://www.ietf.org/rfc/rfc1738.txt">RFC 1738</a>.
Simply pass the <code>user:password</code> before the host with an <code>@</code> sign.</p>
<pre><code class="lang-javascript">var username = &#39;username&#39;,
    password = &#39;password&#39;,
    url = &#39;http://&#39; + username + &#39;:&#39; + password + &#39;@some.server.com&#39;;

request({url: url}, function (error, response, body) {
   // Do more stuff with &#39;body&#39; here
});</code></pre>
<p>Digest authentication is supported, but it only works with <code>sendImmediately</code> set to <code>false</code>; otherwise <code>request</code> will send basic authentication on the initial request, which will probably cause the request to fail.</p>
<p>Bearer authentication is supported, and is activated when the <code>bearer</code> value is available. The value may be either a <code>String</code> or a <code>Function</code> returning a <code>String</code>. Using a function to supply the bearer token is particularly useful if used in conjuction with <code>defaults</code> to allow a single function to supply the last known token at the time or sending a request or to compute one on the fly.</p>
<h2 id="oauth-signing">OAuth Signing</h2>
<p><a href="https://tools.ietf.org/html/rfc5849">OAuth version 1.0</a> is supported.  The
default signing algorithm is
<a href="https://tools.ietf.org/html/rfc5849#section-3.4.2">HMAC-SHA1</a>:</p>
<pre><code class="lang-javascript">// Twitter OAuth
var qs = require(&#39;querystring&#39;)
  , oauth =
    { callback: &#39;http://mysite.com/callback/&#39;
    , consumer_key: CONSUMER_KEY
    , consumer_secret: CONSUMER_SECRET
    }
  , url = &#39;https://api.twitter.com/oauth/request_token&#39;
  ;
request.post({url:url, oauth:oauth}, function (e, r, body) {
  // Ideally, you would take the body in the response
  // and construct a URL that a user clicks on (like a sign in button).
  // The verifier is only available in the response after a user has
  // verified with twitter that they are authorizing your app.
  var access_token = qs.parse(body)
    , oauth =
      { consumer_key: CONSUMER_KEY
      , consumer_secret: CONSUMER_SECRET
      , token: access_token.oauth_token
      , verifier: access_token.oauth_verifier
      }
    , url = &#39;https://api.twitter.com/oauth/access_token&#39;
    ;
  request.post({url:url, oauth:oauth}, function (e, r, body) {
    var perm_token = qs.parse(body)
      , oauth =
        { consumer_key: CONSUMER_KEY
        , consumer_secret: CONSUMER_SECRET
        , token: perm_token.oauth_token
        , token_secret: perm_token.oauth_token_secret
        }
      , url = &#39;https://api.twitter.com/1.1/users/show.json?&#39;
      , params =
        { screen_name: perm_token.screen_name
        , user_id: perm_token.user_id
        }
      ;
    url += qs.stringify(params)
    request.get({url:url, oauth:oauth, json:true}, function (e, r, user) {
      console.log(user)
    })
  })
})</code></pre>
<p>For <a href="https://tools.ietf.org/html/rfc5849#section-3.4.3">RSA-SHA1 signing</a>, make
the following changes to the OAuth options object:</p>
<ul>
<li>Pass <code>signature_method : &#39;RSA-SHA1&#39;</code></li>
<li>Instead of <code>consumer_secret</code>, specify a <code>private_key</code> string in
<a href="http://how2ssl.com/articles/working_with_pem_files/">PEM format</a></li>
</ul>
<h2 id="custom-http-headers">Custom HTTP Headers</h2>
<p>HTTP Headers, such as <code>User-Agent</code>, can be set in the <code>options</code> object.
In the example below, we call the github API to find out the number
of stars and forks for the request repository. This requires a
custom <code>User-Agent</code> header as well as https.</p>
<pre><code class="lang-javascript">var request = require(&#39;request&#39;);

var options = {
    url: &#39;https://api.github.com/repos/request/request&#39;,
    headers: {
        &#39;User-Agent&#39;: &#39;request&#39;
    }
};

function callback(error, response, body) {
    if (!error &amp;&amp; response.statusCode == 200) {
        var info = JSON.parse(body);
        console.log(info.stargazers_count + &quot; Stars&quot;);
        console.log(info.forks_count + &quot; Forks&quot;);
    }
}

request(options, callback);</code></pre>
<h2 id="tls-ssl-protocol">TLS/SSL Protocol</h2>
<p>TLS/SSL Protocol options, such as <code>cert</code>, <code>key</code> and <code>passphrase</code>, can be
set in the <code>agentOptions</code> property of the <code>options</code> object.
In the example below, we call an API requires client side SSL certificate
(in PEM format) with passphrase protected private key (in PEM format) and disable the SSLv3 protocol:</p>
<pre><code class="lang-javascript">var fs = require(&#39;fs&#39;)
    , path = require(&#39;path&#39;)
    , certFile = path.resolve(__dirname, &#39;ssl/client.crt&#39;)
    , keyFile = path.resolve(__dirname, &#39;ssl/client.key&#39;)
    , request = require(&#39;request&#39;);

var options = {
    url: &#39;https://api.some-server.com/&#39;,
    agentOptions: {
        cert: fs.readFileSync(certFile),
        key: fs.readFileSync(keyFile),
        // Or use `pfx` property replacing `cert` and `key` when using private key, certificate and CA certs in PFX or PKCS12 format:
        // pfx: fs.readFileSync(pfxFilePath),
        passphrase: &#39;password&#39;,
        securityOptions: &#39;SSL_OP_NO_SSLv3&#39;
    }
};

request.get(options);</code></pre>
<p>It is able to force using SSLv3 only by specifying <code>secureProtocol</code>:</p>
<pre><code class="lang-javascript">request.get({
    url: &#39;https://api.some-server.com/&#39;,
    agentOptions: {
        secureProtocol: &#39;SSLv3_method&#39;
    }
});</code></pre>
<p>It is possible to accept other certificates than those signed by generally allowed Certificate Authorities (CAs).
This can be useful, for example,  when using self-signed certificates.
To allow a different certificate, you can specify the signing CA by adding the contents of the CA&#39;s certificate file to the <code>agentOptions</code>:</p>
<pre><code class="lang-javascript">request.get({
    url: &#39;https://api.some-server.com/&#39;,
    agentOptions: {
        ca: fs.readFileSync(&#39;ca.cert.pem&#39;)
    }
});</code></pre>
<h2 id="request-options-callback-">request(options, callback)</h2>
<p>The first argument can be either a <code>url</code> or an <code>options</code> object. The only required option is <code>uri</code>; all others are optional.</p>
<ul>
<li><code>uri</code> || <code>url</code> - fully qualified uri or a parsed url object from <code>url.parse()</code></li>
<li><code>qs</code> - object containing querystring values to be appended to the <code>uri</code></li>
<li><code>useQuerystring</code> - If true, use <code>querystring</code> to stringify and parse
querystrings, otherwise use <code>qs</code> (default: <code>false</code>).  Set this option to
<code>true</code> if you need arrays to be serialized as <code>foo=bar&amp;foo=baz</code> instead of the
default <code>foo[0]=bar&amp;foo[1]=baz</code>.</li>
<li><code>method</code> - http method (default: <code>&quot;GET&quot;</code>)</li>
<li><code>headers</code> - http headers (default: <code>{}</code>)</li>
<li><code>body</code> - entity body for PATCH, POST and PUT requests. Must be a <code>Buffer</code> or <code>String</code>, unless <code>json</code> is <code>true</code>. If <code>json</code> is <code>true</code>, then <code>body</code> must be a JSON-serializable object.</li>
<li><code>form</code> - when passed an object or a querystring, this sets <code>body</code> to a querystring representation of value, and adds <code>Content-type: application/x-www-form-urlencoded</code> header. When passed no options, a <code>FormData</code> instance is returned (and is piped to request). See &quot;Forms&quot; section above.</li>
<li><code>formData</code> - Data to pass for a <code>multipart/form-data</code> request. See
<a href="#forms">Forms</a> section above.</li>
<li><code>multipart</code> - array of objects which contain their own headers and <code>body</code>
attributes. Sends a <code>multipart/related</code> request. See <a href="#forms">Forms</a> section
above.<ul>
<li>Alternatively you can pass in an object <code>{chunked: false, data: []}</code> where
<code>chunked</code> is used to specify whether the request is sent in
<a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked transfer encoding</a>
(the default is <code>chunked: true</code>).  In non-chunked requests, data items with
body streams are not allowed.</li>
</ul>
</li>
<li><code>auth</code> - A hash containing values <code>user</code> || <code>username</code>, <code>pass</code> || <code>password</code>, and <code>sendImmediately</code> (optional).  See documentation above.</li>
<li><code>json</code> - sets <code>body</code> but to JSON representation of value and adds <code>Content-type: application/json</code> header.  Additionally, parses the response body as JSON.</li>
<li><code>jsonReviver</code> - a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">reviver function</a> that will be passed to <code>JSON.parse()</code> when parsing a JSON response body.</li>
<li><code>preambleCRLF</code> - append a newline/CRLF before the boundary of your <code>multipart/form-data</code> request.</li>
<li><code>postambleCRLF</code> - append a newline/CRLF at the end of the boundary of your <code>multipart/form-data</code> request.</li>
<li><code>followRedirect</code> - follow HTTP 3xx responses as redirects (default: <code>true</code>). This property can also be implemented as function which gets <code>response</code> object as a single argument and should return <code>true</code> if redirects should continue or <code>false</code> otherwise.</li>
<li><code>followAllRedirects</code> - follow non-GET HTTP 3xx responses as redirects (default: <code>false</code>)</li>
<li><code>maxRedirects</code> - the maximum number of redirects to follow (default: <code>10</code>)</li>
<li><code>encoding</code> - Encoding to be used on <code>setEncoding</code> of response data. If <code>null</code>, the <code>body</code> is returned as a <code>Buffer</code>. Anything else <strong>(including the default value of <code>undefined</code>)</strong> will be passed as the <a href="http://nodejs.org/api/buffer.html#buffer_buffer">encoding</a> parameter to <code>toString()</code> (meaning this is effectively <code>utf8</code> by default).</li>
<li><code>pool</code> - An object describing which agents to use for the request. If this option is omitted the request will use the global agent (as long as <a href="request.js#L747">your options allow for it</a>). Otherwise, request will search the pool for your custom agent. If no custom agent is found, a new agent will be created and added to the pool.<ul>
<li>A <code>maxSockets</code> property can also be provided on the <code>pool</code> object to set the max number of sockets for all agents created (ex: <code>pool: {maxSockets: Infinity}</code>).</li>
<li>Note that if you are sending multiple requests in a loop and creating
multiple new <code>pool</code> objects, <code>maxSockets</code> will not work as intended.  To
work around this, either use <a href="#requestdefaultsoptions"><code>request.defaults</code></a>
with your pool options or create the pool object with the <code>maxSockets</code>
property outside of the loop.</li>
</ul>
</li>
<li><code>timeout</code> - Integer containing the number of milliseconds to wait for a request to respond before aborting the request</li>
<li><code>proxy</code> - An HTTP proxy to be used. Supports proxy Auth with Basic Auth, identical to support for the <code>url</code> parameter (by embedding the auth info in the <code>uri</code>)</li>
<li><code>oauth</code> - Options for OAuth HMAC-SHA1 signing. See documentation above.</li>
<li><code>hawk</code> - Options for <a href="https://github.com/hueniverse/hawk">Hawk signing</a>. The <code>credentials</code> key must contain the necessary signing info, <a href="https://github.com/hueniverse/hawk#usage-example">see hawk docs for details</a>.</li>
<li><code>strictSSL</code> - If <code>true</code>, requires SSL certificates be valid. <strong>Note:</strong> to use your own certificate authority, you need to specify an agent that was created with that CA as an option.</li>
<li><p><code>agentOptions</code> - Object containing user agent options. See documentation above. <strong>Note:</strong> <a href="http://nodejs.org/api/tls.html#tls_tls_connect_options_callback">see tls API doc for TLS/SSL options</a>.</p>
</li>
<li><p><code>jar</code> - If <code>true</code> and <code>tough-cookie</code> is installed, remember cookies for future use (or define your custom cookie jar; see examples section)</p>
</li>
<li><code>aws</code> - <code>object</code> containing AWS signing information. Should have the properties <code>key</code>, <code>secret</code>. Also requires the property <code>bucket</code>, unless you’re specifying your <code>bucket</code> as part of the path, or the request doesn’t use a bucket (i.e. GET Services)</li>
<li><code>httpSignature</code> - Options for the <a href="https://github.com/joyent/node-http-signature/blob/master/http_signing.md">HTTP Signature Scheme</a> using <a href="https://github.com/joyent/node-http-signature">Joyent&#39;s library</a>. The <code>keyId</code> and <code>key</code> properties must be specified. See the docs for other options.</li>
<li><code>localAddress</code> - Local interface to bind for network connections.</li>
<li><code>gzip</code> - If <code>true</code>, add an <code>Accept-Encoding</code> header to request compressed content encodings from the server (if not already present) and decode supported content encodings in the response.  <strong>Note:</strong> Automatic decoding of the response content is performed on the body data returned through <code>request</code> (both through the <code>request</code> stream and passed to the callback function) but is not performed on the <code>response</code> stream (available from the <code>response</code> event) which is the unmodified <code>http.IncomingMessage</code> object which may contain compressed data. See example below.</li>
<li><code>tunnel</code> - If <code>true</code>, then <em>always</em> use a tunneling proxy.  If
<code>false</code> (default), then tunneling will only be used if the
destination is <code>https</code>, or if a previous request in the redirect
chain used a tunneling proxy.</li>
<li><code>proxyHeaderWhiteList</code> - A whitelist of headers to send to a
tunneling proxy.</li>
<li><code>proxyHeaderExclusiveList</code> - A whitelist of headers to send
exclusively to a tunneling proxy and not to destination.</li>
</ul>
<p>The callback argument gets 3 arguments:</p>
<ol>
<li>An <code>error</code> when applicable (usually from <a href="http://nodejs.org/api/http.html#http_class_http_clientrequest"><code>http.ClientRequest</code></a> object)</li>
<li>An <a href="http://nodejs.org/api/http.html#http_http_incomingmessage"><code>http.IncomingMessage</code></a> object</li>
<li>The third is the <code>response</code> body (<code>String</code> or <code>Buffer</code>, or JSON object if the <code>json</code> option is supplied)</li>
</ol>
<h2 id="convenience-methods">Convenience methods</h2>
<p>There are also shorthand methods for different HTTP METHODs and some other conveniences.</p>
<h3 id="request-defaults-options-">request.defaults(options)</h3>
<p>This method <strong>returns a wrapper</strong> around the normal request API that defaults
to whatever options you pass to it.</p>
<p><strong>Note:</strong> <code>request.defaults()</code> <strong>does not</strong> modify the global request API;
instead, it <strong>returns a wrapper</strong> that has your default settings applied to it.</p>
<p><strong>Note:</strong> You can call <code>.defaults()</code> on the wrapper that is returned from
<code>request.defaults</code> to add/override defaults that were previously defaulted.</p>
<p>For example:</p>
<pre><code class="lang-javascript">//requests using baseRequest() will set the &#39;x-token&#39; header
var baseRequest = request.defaults({
  headers: {x-token: &#39;my-token&#39;}
})

//requests using specialRequest() will include the &#39;x-token&#39; header set in
//baseRequest and will also include the &#39;special&#39; header
var specialRequest = baseRequest.defaults({
  headers: {special: &#39;special value&#39;}
})</code></pre>
<h3 id="request-put">request.put</h3>
<p>Same as <code>request()</code>, but defaults to <code>method: &quot;PUT&quot;</code>.</p>
<pre><code class="lang-javascript">request.put(url)</code></pre>
<h3 id="request-patch">request.patch</h3>
<p>Same as <code>request()</code>, but defaults to <code>method: &quot;PATCH&quot;</code>.</p>
<pre><code class="lang-javascript">request.patch(url)</code></pre>
<h3 id="request-post">request.post</h3>
<p>Same as <code>request()</code>, but defaults to <code>method: &quot;POST&quot;</code>.</p>
<pre><code class="lang-javascript">request.post(url)</code></pre>
<h3 id="request-head">request.head</h3>
<p>Same as request() but defaults to <code>method: &quot;HEAD&quot;</code>.</p>
<pre><code class="lang-javascript">request.head(url)</code></pre>
<h3 id="request-del">request.del</h3>
<p>Same as <code>request()</code>, but defaults to <code>method: &quot;DELETE&quot;</code>.</p>
<pre><code class="lang-javascript">request.del(url)</code></pre>
<h3 id="request-get">request.get</h3>
<p>Same as <code>request()</code> (for uniformity).</p>
<pre><code class="lang-javascript">request.get(url)</code></pre>
<h3 id="request-cookie">request.cookie</h3>
<p>Function that creates a new cookie.</p>
<pre><code class="lang-javascript">request.cookie(&#39;key1=value1&#39;)</code></pre>
<h3 id="request-jar-">request.jar()</h3>
<p>Function that creates a new cookie jar.</p>
<pre><code class="lang-javascript">request.jar()</code></pre>
<h2 id="examples-">Examples:</h2>
<pre><code class="lang-javascript">  var request = require(&#39;request&#39;)
    , rand = Math.floor(Math.random()*100000000).toString()
    ;
  request(
    { method: &#39;PUT&#39;
    , uri: &#39;http://mikeal.iriscouch.com/testjs/&#39; + rand
    , multipart:
      [ { &#39;content-type&#39;: &#39;application/json&#39;
        ,  body: JSON.stringify({foo: &#39;bar&#39;, _attachments: {&#39;message.txt&#39;: {follows: true, length: 18, &#39;content_type&#39;: &#39;text/plain&#39; }}})
        }
      , { body: &#39;I am an attachment&#39; }
      ]
    }
  , function (error, response, body) {
      if(response.statusCode == 201){
        console.log(&#39;document saved as: http://mikeal.iriscouch.com/testjs/&#39;+ rand)
      } else {
        console.log(&#39;error: &#39;+ response.statusCode)
        console.log(body)
      }
    }
  )</code></pre>
<p>For backwards-compatibility, response compression is not supported by default.
To accept gzip-compressed responses, set the <code>gzip</code> option to <code>true</code>.  Note
that the body data passed through <code>request</code> is automatically decompressed
while the response object is unmodified and will contain compressed data if
the server sent a compressed response.</p>
<pre><code class="lang-javascript">  var request = require(&#39;request&#39;)
  request(
    { method: &#39;GET&#39;
    , uri: &#39;http://www.google.com&#39;
    , gzip: true
    }
  , function (error, response, body) {
      // body is the decompressed response body
      console.log(&#39;server encoded the data as: &#39; + (response.headers[&#39;content-encoding&#39;] || &#39;identity&#39;))
      console.log(&#39;the decoded data is: &#39; + body)
    }
  ).on(&#39;data&#39;, function(data) {
    // decompressed data as it is received
    console.log(&#39;decoded chunk: &#39; + data)
  })
  .on(&#39;response&#39;, function(response) {
    // unmodified http.IncomingMessage object
    response.on(&#39;data&#39;, function(data) {
      // compressed data as it is received
      console.log(&#39;received &#39; + data.length + &#39; bytes of compressed data&#39;)
    })
  })</code></pre>
<p>Cookies are disabled by default (else, they would be used in subsequent requests). To enable cookies, set <code>jar</code> to <code>true</code> (either in <code>defaults</code> or <code>options</code>) and install <code>tough-cookie</code>.</p>
<pre><code class="lang-javascript">var request = request.defaults({jar: true})
request(&#39;http://www.google.com&#39;, function () {
  request(&#39;http://images.google.com&#39;)
})</code></pre>
<p>To use a custom cookie jar (instead of <code>request</code>’s global cookie jar), set <code>jar</code> to an instance of <code>request.jar()</code> (either in <code>defaults</code> or <code>options</code>)</p>
<pre><code class="lang-javascript">var j = request.jar()
var request = request.defaults({jar:j})
request(&#39;http://www.google.com&#39;, function () {
  request(&#39;http://images.google.com&#39;)
})</code></pre>
<p>OR</p>
<pre><code class="lang-javascript">var j = request.jar();
var cookie = request.cookie(&#39;key1=value1&#39;);
var url = &#39;http://www.google.com&#39;;
j.setCookie(cookie, url);
request({url: url, jar: j}, function () {
  request(&#39;http://images.google.com&#39;)
})</code></pre>
<p>To use a custom cookie store (such as a
<a href="https://github.com/mitsuru/tough-cookie-filestore"><code>FileCookieStore</code></a>
which supports saving to and restoring from JSON files), pass it as a parameter
to <code>request.jar()</code>:</p>
<pre><code class="lang-javascript">var FileCookieStore = require(&#39;tough-cookie-filestore&#39;);
// NOTE - currently the &#39;cookies.json&#39; file must already exist!
var j = request.jar(new FileCookieStore(&#39;cookies.json&#39;));
request = request.defaults({ jar : j })
request(&#39;http://www.google.com&#39;, function() {
  request(&#39;http://images.google.com&#39;)
})</code></pre>
<p>The cookie store must be a
<a href="https://github.com/goinstant/tough-cookie"><code>tough-cookie</code></a>
store and it must support synchronous operations; see the
<a href="https://github.com/goinstant/tough-cookie/#cookiestore-api"><code>CookieStore</code> API docs</a>
for details.</p>
<p>To inspect your cookie jar after a request:</p>
<pre><code class="lang-javascript">var j = request.jar()
request({url: &#39;http://www.google.com&#39;, jar: j}, function () {
  var cookie_string = j.getCookieString(uri); // &quot;key1=value1; key2=value2; ...&quot;
  var cookies = j.getCookies(uri);
  // [{key: &#39;key1&#39;, value: &#39;value1&#39;, domain: &quot;www.google.com&quot;, ...}, ...]
})</code></pre>
<h2 id="debugging">Debugging</h2>
<p>There are at least three ways to debug the operation of <code>request</code>:</p>
<ol>
<li><p>Launch the node process like <code>NODE_DEBUG=request node script.js</code>
(<code>lib,request,otherlib</code> works too).</p>
</li>
<li><p>Set <code>require(&#39;request&#39;).debug = true</code> at any time (this does the same thing
as #1).</p>
</li>
<li><p>Use the <a href="https://github.com/nylen/request-debug">request-debug module</a> to
view request and response headers and bodies.</p>
</li>
</ol>

  </body>
</html>
