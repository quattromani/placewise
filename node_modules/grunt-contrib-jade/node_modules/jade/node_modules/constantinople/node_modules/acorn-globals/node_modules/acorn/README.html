<!DOCTYPE  html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>doc</title>
    <style>
      /*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }
    </style>
  </head>
  <body>  
    <h1 id="acorn">Acorn</h1>
<p><a href="https://travis-ci.org/marijnh/acorn"><img src="https://travis-ci.org/marijnh/acorn.svg?branch=master" alt="Build Status"></a></p>
<p>A tiny, fast JavaScript parser, written completely in JavaScript.</p>
<h2 id="installation">Installation</h2>
<p>The easiest way to install acorn is with <a href="http://npmjs.org"><code>npm</code></a>.</p>
<pre><code class="lang-sh">npm install acorn</code></pre>
<p>Alternately, download the source.</p>
<pre><code class="lang-sh">git clone https://github.com/marijnh/acorn.git</code></pre>
<h2 id="components">Components</h2>
<p>When run in a CommonJS (node.js) or AMD environment, exported values
appear in the interfaces exposed by the individual files, as usual.
When loaded in the browser (Acorn works in any JS-enabled browser more
recent than IE5) without any kind of module management, a single
global object <code>acorn</code> will be defined, and all the exported properties
will be added to that.</p>
<h3 id="acorn-js">acorn.js</h3>
<p>This file contains the actual parser (and is what you get when you
<code>require(&quot;acorn&quot;)</code> in node.js).</p>
<p><strong>parse</strong><code>(input, options)</code> is used to parse a JavaScript program.
The <code>input</code> parameter is a string, <code>options</code> can be undefined or an
object setting some of the options listed below. The return value will
be an abstract syntax tree object as specified by the
<a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">Mozilla Parser API</a>.</p>
<p>When  encountering   a  syntax   error,  the   parser  will   raise  a
<code>SyntaxError</code> object with a meaningful  message. The error object will
have a <code>pos</code> property that indicates the character offset at which the
error occurred,  and a <code>loc</code>  object that contains a  <code>{line, column}</code>
object referring to that same position.</p>
<ul>
<li><p><strong>ecmaVersion</strong>: Indicates the ECMAScript version to parse. Must be
either 3, 5, or 6. This influences support for strict mode, the set
of reserved words, and support for new syntax features. Default is 5.</p>
</li>
<li><p><strong>strictSemicolons</strong>: If <code>true</code>, prevents the parser from doing
automatic semicolon insertion, and statements that do not end with
a semicolon will generate an error. Defaults to <code>false</code>.</p>
</li>
<li><p><strong>allowTrailingCommas</strong>: If <code>false</code>, the parser will not allow
trailing commas in array and object literals. Default is <code>true</code>.</p>
</li>
<li><p><strong>forbidReserved</strong>: If <code>true</code>, using a reserved word will generate
an error. Defaults to <code>false</code>. When given the value <code>&quot;everywhere&quot;</code>,
reserved words and keywords can also not be used as property names
(as in Internet Explorer&#39;s old parser).</p>
</li>
<li><p><strong>allowReturnOutsideFunction</strong>: By default, a return statement at
the top level raises an error. Set this to <code>true</code> to accept such
code.</p>
</li>
<li><p><strong>locations</strong>: When <code>true</code>, each node has a <code>loc</code> object attached
with <code>start</code> and <code>end</code> subobjects, each of which contains the
one-based line and zero-based column numbers in <code>{line, column}</code>
form. Default is <code>false</code>.</p>
</li>
<li><p><strong>onToken</strong>: If a function is passed for this option, each found
token will be passed in same format as <code>tokenize()</code> returns.</p>
<p>If array is passed, each found token is pushed to it.</p>
<p>Note that you are not allowed to call the parser from the
callback—that will corrupt its internal state.</p>
</li>
<li><p><strong>onComment</strong>: If a function is passed for this option, whenever a
comment is encountered the function will be called with the
following parameters:</p>
<ul>
<li><code>block</code>: <code>true</code> if the comment is a block comment, false if it
is a line comment.</li>
<li><code>text</code>: The content of the comment.</li>
<li><code>start</code>: Character offset of the start of the comment.</li>
<li><code>end</code>: Character offset of the end of the comment.</li>
</ul>
<p>When the <code>locations</code> options is on, the <code>{line, column}</code> locations
of the comment’s start and end are passed as two additional
parameters.</p>
<p>If array is passed for this option, each found comment is pushed
to it as object in Esprima format:</p>
<pre><code class="lang-javascript">{
  &quot;type&quot;: &quot;Line&quot; | &quot;Block&quot;,
  &quot;value&quot;: &quot;comment text&quot;,
  &quot;range&quot;: ...,
  &quot;loc&quot;: ...
}</code></pre>
<p>Note that you are not allowed to call the parser from the
callback—that will corrupt its internal state.</p>
</li>
<li><p><strong>ranges</strong>: Nodes have their start and end characters offsets
recorded in <code>start</code> and <code>end</code> properties (directly on the node,
rather than the <code>loc</code> object, which holds line/column data. To also
add a <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=745678">semi-standardized</a> &quot;range&quot; property holding a
<code>[start, end]</code> array with the same numbers, set the <code>ranges</code> option
to <code>true</code>.</p>
</li>
<li><p><strong>program</strong>: It is possible to parse multiple files into a single
AST by passing the tree produced by parsing the first file as the
<code>program</code> option in subsequent parses. This will add the toplevel
forms of the parsed file to the &quot;Program&quot; (top) node of an existing
parse tree.</p>
</li>
<li><p><strong>sourceFile</strong>: When the <code>locations</code> option is <code>true</code>, you can pass
this option to add a <code>source</code> attribute in every node’s <code>loc</code>
object. Note that the contents of this option are not examined or
processed in any way; you are free to use whatever format you
choose.</p>
</li>
<li><p><strong>directSourceFile</strong>: Like <code>sourceFile</code>, but a <code>sourceFile</code> property
will be added directly to the nodes, rather than the <code>loc</code> object.</p>
</li>
</ul>
<p><strong>getLineInfo</strong><code>(input, offset)</code> can be used to get a <code>{line,
column}</code> object for a given program string and character offset.</p>
<p><strong>tokenize</strong><code>(input, options)</code> exports a primitive interface to
Acorn&#39;s tokenizer. The function takes an input string and options
similar to <code>parse</code> (though only some options are meaningful here), and
returns a function that can be called repeatedly to read a single
token, and returns a <code>{start, end, type, value}</code> object (with added
<code>loc</code> property when the <code>locations</code> option is enabled and <code>range</code>
property when the <code>ranges</code> option is enabled).</p>
<p><strong>tokTypes</strong> holds an object mapping names to the token type objects
that end up in the <code>type</code> properties of tokens.</p>
<h4 id="note-on-using-with-escodegen-escodegen-">Note on using with <a href="https://github.com/Constellation/escodegen">Escodegen</a></h4>
<p>Escodegen supports generating comments from AST, attached in
Esprima-specific format. In order to simulate same format in
Acorn, consider following example:</p>
<pre><code class="lang-javascript">var comments = [], tokens = [];

var ast = acorn.parse(&#39;var x = 42; // answer&#39;, {
    // collect ranges for each node
    ranges: true,
    // collect comments in Esprima&#39;s format
    onComment: comments,
    // collect token ranges
    onToken: tokens
});

// attach comments using collected information
escodegen.attachComments(ast, comments, tokens);

// generate code
console.log(escodegen.generate(ast, {comment: true}));
// &gt; &#39;var x = 42;    // answer&#39;</code></pre>
<h4 id="using-acorn-in-an-environment-with-a-content-security-policy">Using Acorn in an environment with a Content Security Policy</h4>
<p>Some contexts, such as Chrome Web Apps, disallow run-time code evaluation.
Acorn uses <code>new Function</code> to generate fast functions that test whether
a word is in a given set, and will trigger a security error when used
in a context with such a
<a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/#eval-too">Content Security Policy</a>
(see <a href="https://github.com/marijnh/acorn/issues/90">#90</a> and
<a href="https://github.com/marijnh/acorn/issues/123">#123</a>).</p>
<p>The <code>bin/without_eval</code> script can be used to generate a version of
<code>acorn.js</code> that has the generated code inlined, and can thus run
without evaluating anything. In versions of this library downloaded
from NPM, this script will be available as <code>acorn_csp.js</code>.</p>
<h3 id="acorn_loose-js">acorn_loose.js</h3>
<p>This file implements an error-tolerant parser. It exposes a single
function.</p>
<p><strong>parse_dammit</strong><code>(input, options)</code> takes the same arguments and
returns the same syntax tree as the <code>parse</code> function in <code>acorn.js</code>,
but never raises an error, and will do its best to parse syntactically
invalid code in as meaningful a way as it can. It&#39;ll insert identifier
nodes with name <code>&quot;✖&quot;</code> as placeholders in places where it can&#39;t make
sense of the input. Depends on <code>acorn.js</code>, because it uses the same
tokenizer.</p>
<h3 id="util-walk-js">util/walk.js</h3>
<p>Implements an abstract syntax tree walker. Will store its interface in
<code>acorn.walk</code> when used without a module system.</p>
<p><strong>simple</strong><code>(node, visitors, base, state)</code> does a &#39;simple&#39; walk over
a tree. <code>node</code> should be the AST node to walk, and <code>visitors</code> an
object with properties whose names correspond to node types in the
<a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">Mozilla Parser API</a>. The properties should contain functions
that will be called with the node object and, if applicable the state
at that point. The last two arguments are optional. <code>base</code> is a walker
algorithm, and <code>state</code> is a start state. The default walker will
simply visit all statements and expressions and not produce a
meaningful state. (An example of a use of state it to track scope at
each point in the tree.)</p>
<p><strong>ancestor</strong><code>(node, visitors, base, state)</code> does a &#39;simple&#39; walk over
a tree, building up an array of ancestor nodes (including the current node)
and passing the array to callbacks in the <code>state</code> parameter.</p>
<p><strong>recursive</strong><code>(node, state, functions, base)</code> does a &#39;recursive&#39;
walk, where the walker functions are responsible for continuing the
walk on the child nodes of their target node. <code>state</code> is the start
state, and <code>functions</code> should contain an object that maps node types
to walker functions. Such functions are called with <code>(node, state, c)</code>
arguments, and can cause the walk to continue on a sub-node by calling
the <code>c</code> argument on it with <code>(node, state)</code> arguments. The optional
<code>base</code> argument provides the fallback walker functions for node types
that aren&#39;t handled in the <code>functions</code> object. If not given, the
default walkers will be used.</p>
<p><strong>make</strong><code>(functions, base)</code> builds a new walker object by using the
walker functions in <code>functions</code> and filling in the missing ones by
taking defaults from <code>base</code>.</p>
<p><strong>findNodeAt</strong><code>(node, start, end, test, base, state)</code> tries to
locate a node in a tree at the given start and/or end offsets, which
satisfies the predicate <code>test</code>. <code>start</code> end <code>end</code> can be either <code>null</code>
(as wildcard) or a number. <code>test</code> may be a string (indicating a node
type) or a function that takes <code>(nodeType, node)</code> arguments and
returns a boolean indicating whether this node is interesting. <code>base</code>
and <code>state</code> are optional, and can be used to specify a custom walker.
Nodes are tested from inner to outer, so if two nodes match the
boundaries, the inner one will be preferred.</p>
<p><strong>findNodeAround</strong><code>(node, pos, test, base, state)</code> is a lot like
<code>findNodeAt</code>, but will match any node that exists &#39;around&#39; (spanning)
the given position.</p>
<p><strong>findNodeAfter</strong><code>(node, pos, test, base, state)</code> is similar to
<code>findNodeAround</code>, but will match all nodes <em>after</em> the given position
(testing outer nodes before inner nodes).</p>
<h2 id="command-line-interface">Command line interface</h2>
<p>The <code>bin/acorn</code> utility can be used to parse a file from the command
line. It accepts as arguments its input file and the following
options:</p>
<ul>
<li><p><code>--ecma3|--ecma5|--ecma6</code>: Sets the ECMAScript version to parse. Default is
version 5.</p>
</li>
<li><p><code>--strictSemicolons</code>: Prevents the parser from doing automatic
semicolon insertion. Statements that do not end in semicolons will
generate an error.</p>
</li>
<li><p><code>--locations</code>: Attaches a &quot;loc&quot; object to each node with &quot;start&quot; and
&quot;end&quot; subobjects, each of which contains the one-based line and
zero-based column numbers in <code>{line, column}</code> form.</p>
</li>
<li><p><code>--compact</code>: No whitespace is used in the AST output.</p>
</li>
<li><p><code>--silent</code>: Do not output the AST, just return the exit status.</p>
</li>
<li><p><code>--help</code>: Print the usage information and quit.</p>
</li>
</ul>
<p>The utility spits out the syntax tree as JSON data.</p>

  </body>
</html>
